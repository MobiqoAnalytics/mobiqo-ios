// mobiqo-ios/Sources/Models.swift

import Foundation

/// Additional user data for sync and update operations
public struct AdditionalData {
    /// Optional user identifier
    public let userId: String?
    /// Optional user display name
    public let userName: String?
    /// Optional user email address
    public let userEmail: String?
    /// Optional referrer/source tracking
    public let referrer: String?

    public init(userId: String? = nil, userName: String? = nil, userEmail: String? = nil, referrer: String? = nil) {
        self.userId = userId
        self.userName = userName
        self.userEmail = userEmail
        self.referrer = referrer
    }

    /// Converts AdditionalData to the personal_data format expected by the API
    func toPersonalData() -> [String: Any?] {
        return [
            "id": userId,
            "name": userName,
            "email": userEmail,
            "referrer": referrer
        ]
    }
}

/// Represents a user within the Mobiqo system, including their device information and Mobiqo-specific attributes.
public struct AppUser: Codable {
    /// The unique identifier for the user within the Mobiqo system.
    /// This ID is generated by Mobiqo upon the first sync.
    public let id: String
    /// The identifier of the Mobiqo project this user belongs to.
    public let projectId: String
    /// Optional. The user's identifier from RevenueCat, if applicable.
    public let revenueCatUserId: String?
    /// A Mobiqo-generated username, typically formatted as `ios_<UUID>`.
    /// This helps in uniquely identifying the user device/installation.
    public let mobiqoUsername: String
    /// The operating system of the user's device (e.g., "iOS").
    public let os: String
    /// The version of the operating system (e.g., "15.1").
    public let osVersion: String
    /// The version of the application (e.g., "1.2.3").
    public let appVersion: String
    /// Optional. The user's country code (e.g., "US").
    public let country: String?
    /// Optional. The user's preferred language code (e.g., "en").
    public let language: String?
    /// The A/B testing group assignment for the user ('red' or 'blue').
    public let group: String
    /// An ISO 8601 formatted timestamp indicating when the user was first seen by Mobiqo.
    /// This is typically set by the server.
    public let firstSeenAt: String
    /// An ISO 8601 formatted timestamp indicating when the user was last seen or active.
    /// This is typically updated by the server on subsequent syncs or heartbeats.
    public let lastSeenAt: String
    /// A list of active entitlements or subscription identifiers for the user.
    public let activeEntitlements: [String]

    enum CodingKeys: String, CodingKey {
        case id
        case projectId = "project_id"
        case revenueCatUserId = "revenue_cat_user_id"
        case mobiqoUsername = "mobiqo_username"
        case os
        case osVersion = "os_version"
        case appVersion = "app_version"
        case country
        case language
        case group
        case firstSeenAt = "first_seen_at"
        case lastSeenAt = "last_seen_at"
        case activeEntitlements = "active_entitlements"
    }
    
    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        
        id = try container.decode(String.self, forKey: .id)
        projectId = try container.decode(String.self, forKey: .projectId)
        revenueCatUserId = try container.decodeIfPresent(String.self, forKey: .revenueCatUserId)
        mobiqoUsername = try container.decode(String.self, forKey: .mobiqoUsername)
        os = try container.decode(String.self, forKey: .os)
        osVersion = try container.decode(String.self, forKey: .osVersion)
        appVersion = try container.decode(String.self, forKey: .appVersion)
        country = try container.decodeIfPresent(String.self, forKey: .country)
        language = try container.decodeIfPresent(String.self, forKey: .language)
        group = try container.decode(String.self, forKey: .group)
        activeEntitlements = try container.decode([String].self, forKey: .activeEntitlements)
        
        // Handle timestamp fields that can be either String or Number
        firstSeenAt = try AppUser.decodeTimestamp(from: container, forKey: .firstSeenAt)
        lastSeenAt = try AppUser.decodeTimestamp(from: container, forKey: .lastSeenAt)
    }
    
    private static func decodeTimestamp(from container: KeyedDecodingContainer<CodingKeys>, forKey key: CodingKeys) throws -> String {
        // First try to decode as String
        if let stringValue = try? container.decode(String.self, forKey: key) {
            return stringValue
        }
        
        // If that fails, try to decode as Double (timestamp)
        if let doubleValue = try? container.decode(Double.self, forKey: key) {
            let date = Date(timeIntervalSince1970: doubleValue / 1000) // Assuming milliseconds
            let formatter = ISO8601DateFormatter()
            return formatter.string(from: date)
        }
        
        // If that fails, try to decode as Int (timestamp)
        if let intValue = try? container.decode(Int.self, forKey: key) {
            let date = Date(timeIntervalSince1970: Double(intValue) / 1000) // Assuming milliseconds
            let formatter = ISO8601DateFormatter()
            return formatter.string(from: date)
        }
        
        // If all attempts fail, throw an error
        throw DecodingError.typeMismatch(String.self, DecodingError.Context(
            codingPath: container.codingPath + [key],
            debugDescription: "Expected String or Number for timestamp field, but could not decode either"
        ))
    }
}

/// Contains various analytics and prediction statistics for a user.
public struct Statistics: Codable {
    /// A score representing the user's purchasing power parity, typically relative to a baseline.
    public let purchasingPowerParity: Double
    /// The predicted probability (0.0 to 1.0) of the user making a purchase.
    public let purchaseIntent: Double
    /// The average revenue per user (ARPU).
    public let avgArpu: Double
    /// The average revenue per paying user (ARPPU).
    public let avgArppu: Double
    /// The predicted average lifetime value (LTV) of the user.
    public let avgLtv: Double

    enum CodingKeys: String, CodingKey {
        case purchasingPowerParity = "purchasing_power_parity"
        case purchaseIntent = "purchase_intent"
        case avgArpu = "avg_arpu"
        case avgArppu = "avg_arppu"
        case avgLtv = "avg_ltv"
    }
}

/// Represents the response received from the `syncUser` method.
public struct SyncUserResponse: Codable {
    /// A boolean indicating whether this sync operation resulted in a new user being created in Mobiqo.
    public let isNewUser: Bool
    /// The complete `AppUser` object, potentially updated by the server (e.g., with a new `id` or `lastSeenAt` timestamp).
    public let appUser: AppUser
    /// The `Statistics` object containing analytics and predictions for the user.
    public let statistics: Statistics
    /// The session ID for the current user session, used for subsequent API calls.
    public let sessionId: String

    enum CodingKeys: String, CodingKey {
        case isNewUser
        case appUser
        case statistics
        case sessionId
    }
}

/// Represents the response received from the `getUserInfo` method.
public struct GetUserInfoResponse: Codable {
    /// The complete `AppUser` object for the requested user.
    public let appUser: AppUser
    /// The `Statistics` object containing analytics and predictions for the user.
    public let statistics: Statistics
}

/// Represents the response from the internal SDK initialization call.
/// This is not directly exposed to the SDK user but is used internally.
struct InitResponse: Codable {
    /// Indicates whether the provided API key and project ID were authorized.
    let authorized: Bool
    /// Contains information about the project if authorization was successful.
    let project: ProjectInfo

    /// Nested struct containing basic project information.
    struct ProjectInfo: Codable {
        /// The unique identifier of the project.
        let id: String
    }
}
